[{"title":"流程图测试","path":"/投稿/f1.html","content":"未来将迁移至d3.js flowchart TD A[Christmas] -->|Get money| B(Go shopping) B --> C{Let me think} C -->|One| D[Laptop] C -->|Two| E[iPhone] C --> |sho|A999[革命] C -->|Three| F[fa:fa-car Car]"},{"title":"浅析当代高考语文作文的反动本质","path":"/转发/浅析当代高考语文作文的反动本质.html","content":"资产阶级专政下的教育制度，是反动的教育制度，而高考的语文和作文，必然会受到反动的侵蚀。下面我来浅析一下其反动本质。 编者按：1.资产阶级的教育已是彻底的迈向反动，对应的，其下属的学科也会全无实证和批判的品质，堕落为禁锢人思想的牢笼。2.在商品经济占统治地位的资本主义社会里，学生对资产阶级而言也是商品，也是流水线上的产品，反动的应试教育不是要培养出真正的心系共产主义革命理想的青年，而是要选拔出资产阶级接班人。3.目前高考的作文以主旋律为主，只讲民族不讲阶级 第一，不讲阶级。一切阶级社会的历史，都是阶级斗争的历史。而在社会主义国家中，资产阶级和无产阶级的矛盾依然长期存在，依然需要继续革命，直到共产主义实现的那一天，才会彻底消灭阶级。如果是真正的社会主义国家，为了继续革命，必然要把阶级斗争从小抓起，而在所谓的“某国特色社会主义国家”中，却不教阶级斗争，那么，只有一种可能，某国特色社会主义就是资本主义。在反动的资本主义教育制度下，学生也不会自觉地在作文中使用阶级分析法去分析各种时事新闻和社会现状，所谓的高考“时评文”，只不过是为统治阶级歌功颂德，或是在无法抓住当前社会主要矛盾是资产阶级与无产阶级的阶级矛盾下，对一些社会丑恶现象，做一些不痛不痒的抨击。 第二，鼓吹英雄史观。中学生为了写好作文，往往会积累许多作文素材。在这些作文素材中，往往把所谓的“企业家”打造为“成功人士”，说是因为这些人想到了什么点子，敢想敢做，努力，抓住机遇，就成功了，这是典型的英雄史观。以马云创业成功为例，英雄史观认为，马云通过他的聪明才智，灵机一动，想到了把互联网与购物结合，并带领团队克服各种困难，战胜各种竞争对手，最后成功了。而人民史观认为，新的科技，即互联网，提高了生产力，而传统的购物方式，无法满足人民对更方便的购物方式的需求。不同的人，包括马云在内，都看到了人民群众有了这个需要，各种提出不同的解决办法。谁的认识最能正确地反映客观现实，并在不断地实践中纠正对客观现实的错误反映，并纠正针对错误的认识产生的错误的方法论，那么谁就最能成功。就算没有马云这个人，也会有邓云、江云、胡云去成功。说到底是人民在创造历史，而不是英雄。 第三，颠倒是非黑白。在反动的资产阶级教育制度下，统治阶级不断地给学生灌输资产阶级思想，告诉学生现在一片和谐景像，太平盛世，欺骗学生们，现在的某国与当年真正为人民服务的一共是一脉相承的。在这种情况下，受了欺骗的学生们，就会在作文中为赵国歌功颂德，把做得一榻糊涂的疫情防控说得多么成功，把早已背叛革命、背叛无产阶级的某国说成是”不忘初心，牢记使命“，把对外资本输出进行经济殖民的”一带一路“说成是平等和谐友好发展，是构建人类命运共同体，对说出”996是福报“的骑在无产阶级头上拉屎的资本家们作为正面素材大肆称赞。正面的作文素材人物，几乎都是资产阶级人物，几乎看不到无产阶级代表。 第四，八股取仕。学生为了作文拿高分，往往不是按照自己真实的所见所闻所思所感所想来写，而是按照某个刻板的格式来写作，如“点正反深联总”、“点提析联结”，在中间的分析部分，往往还要绞尽脑汁，非挤出三个分论点，每个分论点又非要引用一个例子或者一句名言来论证，非要写个200字一个“点提析联结”，时时不忘点题，回扣论点。在文章的最后两段，为了凑字数，就搬出了青年应该如何如何奋斗，不忘写几句某位领导人的”金句“。整篇文章写下来，即使文笔再好，自己满意了，老师满意了，改卷人也满意了，分数是高了，但写出来的文章，所表达的观点，自己都不相信。不少像我一样的，试图跳出这个框架，写正常的作文，带有正常思考能力的作文，但是因为没有掌握物质世界的真理，即马列毛主义，也根本写不出什么好文章，往往分数也不高。最后为了得高分，也不得不写成”八股文“。 只有进行无产阶级革命，推翻反动的资产阶级的反动统治，在无产阶级专政下，实行无产阶级教育制度，教育才能回归正常轨道，学生作文才能回归思辨，真正为无产阶级服务。","tags":["文章"],"categories":["转发"]},{"title":"Hello World","path":"/投稿/hello-world.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"固定列表","path":"/fixed-list/index.html","content":"stick12. 文章2的标题3. 文章3的标题"},{"path":"/flow/d3.v7.js","content":"// https://d3js.org v7.9.0 Copyright 2010-2023 Mike Bostock (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.d3 = global.d3 || {})); })(this, (function (exports) { 'use strict'; var version = \"7.9.0\"; function ascending$3(a, b) { return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; } function descending$2(a, b) { return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN; } function bisector(f) { let compare1, compare2, delta; // If an accessor is specified, promote it to a comparator. In this case we // can test whether the search value is (self-) comparable. We can’t do this // for a comparator (except for specific, known comparators) because we can’t // tell if the comparator is symmetric, and an asymmetric comparator can’t be // used to test whether a single value is comparable. if (f.length !== 2) { compare1 = ascending$3; compare2 = (d, x) => ascending$3(f(d), x); delta = (d, x) => f(d) - x; } else { compare1 = f === ascending$3 || f === descending$2 ? f : zero$1; compare2 = f; delta = f; } function left(a, x, lo = 0, hi = a.length) { if (lo < hi) { if (compare1(x, x) !== 0) return hi; do { const mid = (lo + hi) >>> 1; if (compare2(a[mid], x) < 0) lo = mid + 1; else hi = mid; } while (lo < hi); } return lo; } function right(a, x, lo = 0, hi = a.length) { if (lo < hi) { if (compare1(x, x) !== 0) return hi; do { const mid = (lo + hi) >>> 1; if (compare2(a[mid], x) -delta(a[i], x) ? i - 1 : i; } return {left, center, right}; } function zero$1() { return 0; } function number$3(x) { return x === null ? NaN : +x; } function* numbers(values, valueof) { if (valueof === undefined) { for (let value of values) { if (value != null && (value = +value) >= value) { yield value; } } } else { let index = -1; for (let value of values) { if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) { yield value; } } } } const ascendingBisect = bisector(ascending$3); const bisectRight = ascendingBisect.right; const bisectLeft = ascendingBisect.left; const bisectCenter = bisector(number$3).center; var bisect = bisectRight; function blur(values, r) { if (!((r = +r) >= 0)) throw new RangeError(\"invalid r\"); let length = values.length; if (!((length = Math.floor(length)) >= 0)) throw new RangeError(\"invalid length\"); if (!length || !r) return values; const blur = blurf(r); const temp = values.slice(); blur(values, temp, 0, length, 1); blur(temp, values, 0, length, 1); blur(values, temp, 0, length, 1); return values; } const blur2 = Blur2(blurf); const blurImage = Blur2(blurfImage); function Blur2(blur) { return function(data, rx, ry = rx) { if (!((rx = +rx) >= 0)) throw new RangeError(\"invalid rx\"); if (!((ry = +ry) >= 0)) throw new RangeError(\"invalid ry\"); let {data: values, width, height} = data; if (!((width = Math.floor(width)) >= 0)) throw new RangeError(\"invalid width\"); if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError(\"invalid height\"); if (!width || !height || (!rx && !ry)) return data; const blurx = rx && blur(rx); const blury = ry && blur(ry); const temp = values.slice(); if (blurx && blury) { blurh(blurx, temp, values, width, height); blurh(blurx, values, temp, width, height); blurh(blurx, temp, values, width, height); blurv(blury, values, temp, width, height); blurv(blury, temp, values, width, height); blurv(blury, values, temp, width, height); } else if (blurx) { blurh(blurx, values, temp, width, height); blurh(blurx, temp, values, width, height); blurh(blurx, values, temp, width, height); } else if (blury) { blurv(blury, values, temp, width, height); blurv(blury, temp, values, width, height); blurv(blury, values, temp, width, height); } return data; }; } function blurh(blur, T, S, w, h) { for (let y = 0, n = w * h; y < n;) { blur(T, S, y, y += w, 1); } } function blurv(blur, T, S, w, h) { for (let x = 0, n = w * h; x < w; ++x) { blur(T, S, x, x + n, w); } } function blurfImage(radius) { const blur = blurf(radius); return (T, S, start, stop, step) => { start = value) { delta = value - mean; mean += delta / ++count; sum += delta * (value - mean); } } } if (count > 1) return sum / (count - 1); } function deviation(values, valueof) { const v = variance(values, valueof); return v ? Math.sqrt(v) : v; } function extent$1(values, valueof) { let min; let max; if (valueof === undefined) { for (const value of values) { if (value != null) { if (min === undefined) { if (value >= value) min = max = value; } else { if (min > value) min = value; if (max < value) max = value; } } } } else { let index = -1; for (let value of values) { if ((value = valueof(value, ++index, values)) != null) { if (min === undefined) { if (value >= value) min = max = value; } else { if (min > value) min = value; if (max < value) max = value; } } } } return [min, max]; } // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423 class Adder { constructor() { this._partials = new Float64Array(32); this._n = 0; } add(x) { const p = this._partials; let i = 0; for (let j = 0; j < this._n && j < 32; j++) { const y = p[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x); if (lo) p[i++] = lo; x = hi; } p[i] = x; this._n = i + 1; return this; } valueOf() { const p = this._partials; let n = this._n, x, y, lo, hi = 0; if (n > 0) { hi = p[--n]; while (n > 0) { x = hi; y = p[--n]; hi = x + y; lo = y - (hi - x); if (lo) break; } if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) { y = lo * 2; x = hi + y; if (y == x - hi) hi = x; } } return hi; } } function fsum(values, valueof) { const adder = new Adder(); if (valueof === undefined) { for (let value of values) { if (value = +value) { adder.add(value); } } } else { let index = -1; for (let value of values) { if (value = +valueof(value, ++index, values)) { adder.add(value); } } } return +adder; } function fcumsum(values, valueof) { const adder = new Adder(); let index = -1; return Float64Array.from(values, valueof === undefined ? v => adder.add(+v || 0) : v => adder.add(+valueof(v, ++index, values) || 0) ); } class InternMap extends Map { constructor(entries, key = keyof) { super(); Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}}); if (entries != null) for (const [key, value] of entries) this.set(key, value); } get(key) { return super.get(intern_get(this, key)); } has(key) { return super.has(intern_get(this, key)); } set(key, value) { return super.set(intern_set(this, key), value); } delete(key) { return super.delete(intern_delete(this, key)); } } class InternSet extends Set { constructor(values, key = keyof) { super(); Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}}); if (values != null) for (const value of values) this.add(value); } has(value) { return super.has(intern_get(this, value)); } add(value) { return super.add(intern_set(this, value)); } delete(value) { return super.delete(intern_delete(this, value)); } } function intern_get({_intern, _key}, value) { const key = _key(value); return _intern.has(key) ? _intern.get(key) : value; } function intern_set({_intern, _key}, value) { const key = _key(value); if (_intern.has(key)) return _intern.get(key); _intern.set(key, value); return value; } function intern_delete({_intern, _key}, value) { const key = _key(value); if (_intern.has(key)) { value = _intern.get(key); _intern.delete(key); } return value; } function keyof(value) { return value !== null && typeof value === \"object\" ? value.valueOf() : value; } function identity$9(x) { return x; } function group(values, ...keys) { return nest(values, identity$9, identity$9, keys); } function groups(values, ...keys) { return nest(values, Array.from, identity$9, keys); } function flatten$1(groups, keys) { for (let i = 1, n = keys.length; i < n; ++i) { groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value])); } return groups; } function flatGroup(values, ...keys) { return flatten$1(groups(values, ...keys), keys); } function flatRollup(values, reduce, ...keys) { return flatten$1(rollups(values, reduce, ...keys), keys); } function rollup(values, reduce, ...keys) { return nest(values, identity$9, reduce, keys); } function rollups(values, reduce, ...keys) { return nest(values, Array.from, reduce, keys); } function index$4(values, ...keys) { return nest(values, identity$9, unique, keys); } function indexes(values, ...keys) { return nest(values, Array.from, unique, keys); } function unique(values) { if (values.length !== 1) throw new Error(\"duplicate key\"); return values[0]; } function nest(values, map, reduce, keys) { return (function regroup(values, i) { if (i >= keys.length) return reduce(values); const groups = new InternMap(); const keyof = keys[i++]; let index = -1; for (const value of values) { const key = keyof(value, ++index, values); const group = groups.get(key); if (group) group.push(value); else groups.set(key, [value]); } for (const [key, values] of groups) { groups.set(key, regroup(values, i)); } return map(groups); })(values, 0); } function permute(source, keys) { return Array.from(keys, key => source[key]); } function sort(values, ...F) { if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\"); values = Array.from(values); let [f] = F; if ((f && f.length !== 2) || F.length > 1) { const index = Uint32Array.from(values, (d, i) => i); if (F.length > 1) { F = F.map(f => values.map(f)); index.sort((i, j) => { for (const f of F) { const c = ascendingDefined(f[i], f[j]); if (c) return c; } }); } else { f = values.map(f); index.sort((i, j) => ascendingDefined(f[i], f[j])); } return permute(values, index); } return values.sort(compareDefined(f)); } function compareDefined(compare = ascending$3) { if (compare === ascending$3) return ascendingDefined; if (typeof compare !== \"function\") throw new TypeError(\"compare is not a function\"); return (a, b) => { const x = compare(a, b); if (x || x === 0) return x; return (compare(b, b) === 0) - (compare(a, a) === 0); }; } function ascendingDefined(a, b) { return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0); } function groupSort(values, reduce, key) { return (reduce.length !== 2 ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk))) : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk)))) .map(([key]) => key); } var array$5 = Array.prototype; var slice$3 = array$5.slice; function constant$b(x) { return () => x; } const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2); function tickSpec(start, stop, count) { const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1; let i1, i2, inc; if (power < 0) { inc = Math.pow(10, -power) / factor; i1 = Math.round(start * inc); i2 = Math.round(stop * inc); if (i1 / inc < start) ++i1; if (i2 / inc > stop) --i2; inc = -inc; } else { inc = Math.pow(10, power) * factor; i1 = Math.round(start / inc); i2 = Math.round(stop / inc); if (i1 * inc < start) ++i1; if (i2 * inc > stop) --i2; } if (i2 < i1 && 0.5"}]